% stim_categorize       categorize stimuli into discrete groups according to duration/value
%
% stims = stim_categorize( stims, bins, sameBins, Overwrite )
%
% ARGUMENTS:
% stims         
% an output of parseMultipleChannels. In this case, the last
% element typically describes simultaneous events
% more generally, a vector of structures each conforming to
% the stim_check format. 
%
% bins          {0}         data-independent binning
%               1           data-dependent binning (automatic number of bins)
%               [ n1 n2 ]   number of bins for data-dependent binning (automatic bin edges)
%               { v1 v2 }   edges for data-dependent binning
%
% sameBins      {0}. relevant only for data-dependent binning (i.e. when
%                   bins is not 0)
%
% Overwrite:    1 - compute and write
%               0 - if not filled, compute and write
%               -1 - compute and not write
%               -2 - compute and if different from present, write
%
% DOES
% for each stimulus type, the data are checked for values/durations
% then according to the bins argument (see below) they are assigned integer indices
% this routine updates the 'category' fields of the input stim structure/s
% for each event, there is one 3-element row in the category matrix
% all elements are integers; the format is
%
%       [ type_category value_category duration_category ]
%
% -for sine waves/chirps, the duration_category is actually a frequency
%   caterogy
% -for simultaenous structures, the category field contains a 4th column,
%   which is the class of the simultaneously participating channels (e.g.
%   if there are 3 channels, and all combinations were implemented, there
%   will be 4 classes in this column, corresponding to the 3 pairs and the
%   1 triplet)
% 
% BINS ARGUMENT:
% this argument determines the binning mode. in general, stimuli are
% binned by value (max intensity) and duration (total duration). 
% exceptions:   WN stimuli are binned by the mean and SD intensity
%               chirps/sines are binned by frequency and max intensity 
% binning can be either data-dependent (dependent) or independent 
%  -for data-independent binning, there are 22 default intensity bins, 12
%   default duration bins, and 66/8 frequency bins (either frequency or
%   difference between onset/offset frequencies).
% -for data-dependent binning, bins are generated by clustering the
%   value/duration data for each stimulus type SEPARATELY. 
%   thus, categories are not directly comparable between different stimulus
%   types or sets (recording sessions/files)
% To force identical binning for all stimulus types (except the frequency-based), 
%   set sameBins to 1 (this has the advantage of comparability). To force
%   identical binning for different sessions, use data-independent binning
%
% calls         stim_check, makeedges, bindata, optclust, verb
%
% see also      parseOneChannel, parseMultipleChannels

% 20-jan-13 ES

% revisions
% 21-jan-13 optclust implemented and integrated for data-dependent
%               clustering. one iteration of merging implemented locally.
% 04-feb-13 added a 4th row to caterogy (indicates channel subset class)
% 27-feb-13 bug fixed (sim saved as channel - stepped over - in case of 1
%               stimulus channel only)
% 18-aug-19 cleaned up

% TODO: 
% (1) should consider calling routine to check for source type and decide on
%   the range of values accordingly (LEDs have 10,20,30,40,50,60 mA; LD are
%   typically 25mA,26mA,...,40mA; and DPSS are typically 0.5,1,2..5V)
%   right now I used 12 intensity values, which cover the LED and DPSS range
%   properly but not the LD range
% (2) alternatively, determine the number of bins automatically from the data
%   (this would be data-dependent then), e.g. by k-means clustering with all
%   possible k's and using some AIC or similar criterion                            DONE21jan13
% (3) sameBins option does not work properly when there is a ZAP because
%   then the difference is negative and the log cannot be taken
%   (data-dependent binning mode)

function stims = stim_categorize( stims, bins, sameBins, Overwrite, filebase )

%------------------------------------------------------------------%
% initialization
%------------------------------------------------------------------%
vflag                       = 1;
mfname                      = upper( mfilename );

nargs                       = nargin;
if nargs < 1 || isempty( stims )
    return
end
if nargs < 2 || isempty( bins )
    bins                    = 0;
end
if nargs < 3 || isempty( sameBins )
    sameBins                = 1;
end
if nargs < 4 || isempty( Overwrite )
    Overwrite               = -2;
end
if nargs < 5 || isempty( filebase )
    filebase                = '';
end

% stims
nstims                      = length( stims );
tf                          = false( nstims, 1 );
for i                       = 1 : nstims
    tf( i )                 = stim_check( stims( i ) );
end
if sum( tf ) ~= nstims
    return
end

% check whether to process
if Overwrite == 0 
    filled                  = false( nstims, 1 );
    for i                   = 1 : nstims
        c                   = stims( i ).category;
        if isempty( c ) || sum( sum( c, 1 ) >= size( c, 1 ) ) == size( c, 2 )
            filled( i )     = 1;
        end
    end
    if sum( filled ) == nstims
        return
    end
end

% bins
if numel( bins ) == 1
    if bins == 0
        tmp                 = [ stims.source ]; 
        if isa( tmp, 'cell' )
            kidx            = false( size( tmp ) );
            for i           = 1 : length( tmp )
                if ~isempty( tmp{ i } )
                    kidx( i ) = 1;
                end
            end
            stimSources     = unique( tmp( kidx ) );
        else
            stimSources     = tmp;
        end
        if sum( ismember( stimSources, 'LED'  ) )
            mA              = [ 0.002 0.004 0.006 0.008 0.012 0.018 0.025 0.032 0.038 0.044 0.050 0.056 0.062 ];
        else
            mA              = [];
        end
        if sum( ismember( stimSources, 'LD'  ) )
            mAhi            = 0.024 : 0.001 : 0.044;
        else
            mAhi            = [];
        end
        if sum( ismember( stimSources, { 'DPSS', 'SHUT' } ) )
            V               = [ 0.1 0.25 : 0.25 : 2 2.5 : 0.5 : 5 ];
        else
            V               = [];
        end
        vcenters            = unique( [ mA mAhi V ] );
        dcenters            = [ 1 2 5 10 20 60 100 200 400 800 1600 9600 ] / 1000;             % s
        fcenters            = [ 1 : 12 14 : 2 : 100 110 : 10 : 200 ];                          % Hz
        fmat                = [ 0 10; 0 40; 0 100; 0 200; 10 0; 40 0; 100 0; 200 0 ];              % [ Hz Hz ]
        ccenters            = sort( diff( fmat, [], 2 ) )';
        datadependentBinning = 0;
    else
        datadependentBinning = 1;
    end
else
    if numel( bins ) < 4
        bins                = bins( : );
        n                   = length( bins );
        bins                = [ bins; repmat( bins( end ), [ 4 - n 1 ] ) ];
    end
    if isnumeric( bins( 1 ) )
        nvbins              = bins( 1 );
        ndbins              = bins( 2 );
        nfbins              = bins( 3 );
        ncbins              = bins( 4 );
        datadependentBinning = 1;
    elseif iscell( bins( 1 ) )
        vcenters            = bins{ 1 };
        dcenters            = bins{ 2 };
        fcenters            = bins{ 3 };
        ccenters            = bins{ 4 };
        datadependentBinning = 0;
    else
        error( 'bins must be either a flag, a 2-element vector, or a 2-element cell array of vectors' )
    end
end
if ~datadependentBinning
    dedges                  = makeedges( dcenters );
    vedges                  = makeedges( vcenters );
    fedges                  = makeedges( fcenters );
    cedges                  = makeedges( ccenters );
end

if datadependentBinning
    %rng('default');
end

%------------------------------------------------------------------%
% get the bin edges
%------------------------------------------------------------------%
% first pass over structures to determine which stimulus types were used
utypes = [];
for i = 1 : nstims
    utypes                  = [ utypes; stims( i ).types ];
end
utypes                      = upper( unique( utypes ) );
ntypes                      = length( utypes );

% (optional) second pass to get the proper binning
if datadependentBinning
    if sameBins
        durs                = [];
        vals                = [];
        stats               = [];
        franges             = [];
    end
    
    for k                   = 1 : ntypes
        
        typek               = utypes{ k };
        if ~sameBins
            durs            = [];
            vals            = [];
            stats           = [];
            franges         = [];
        end
        for i               = 1 : nstims
            sidx            = ismember( stims( i ).types, typek );
            nidx            = sum( sidx );
            if nidx == 0
                continue
            end
            durs            = [ durs; stims( i ).durs( sidx ) ];
            vals            = [ vals; stims( i ).vals( sidx ) ];
            stats           = [ stats; stims( i ).stats( sidx, : ) ];
            franges         = [ franges; stims( i ).franges( sidx, : ) ];
        end
        switch typek
            case 'SINES'
                durs        = franges( :, 1 );
            case 'WN'
                vals        = stats( :, 1 ); % mean, not max
                durs        = stats( :, 2 ); % SD, not duration
            case 'ZAP'
                durs        = diff( franges, [], 2 );
        end
        
        if ~sameBins || ( sameBins && k == ntypes )
            if ~sameBins
                h           = k;
            else
                h           = 1;
            end
            
            verb( sprintf( '%s: clustering %s...', mfname, typek ), -vflag )
            for j           = 1 : 2
                if j == 1
                    data    = vals;
                else
                    data    = durs;
                end
                [ clu, mu, sig ] = optclust( data );
                % single cycle ad-hoc 1D merging 
                if length( mu ) > 1
                    s       = squeeze( sig );
                    if length( mu ) == 2
                        g   = geomean( s( make_ai( length( mu ) ) ) );
                    else
                        g   = geomean( s( make_ai( length( mu ) ) ), 2 );
                    end
                    mat     = [ pdist( mu )'  g ];
                    nremove = sum( mat( :, 1 ) <= mat( :, 2 ) * 3 );
                    if nremove > 0
                        verb( sprintf( 'removing %d (%d) clusters! ', nremove, j ), -vflag )
                        [ clu, mu, sig ] = optclust( data, 'sic', [], ( length( mu ) - nremove ) * [ 1 1 ] );
                    end
                end
                [ nclu, slct ] = uhist( clu );
                w           = nclu / length( clu );
                gmm{ j, h } = gmdistribution( mu( slct, : ), sig( :, :, slct ), w );
            end
            verb( sprintf( '%d values, %d durations kept'...
                , gmm{ 1, h }.NComponents, gmm{ 2, h }.NComponents ), vflag )

        end
        
    end % ntypes
    
end

% expand data-independent bins for all stimulus types
if ~datadependentBinning
    
    vedges0                 = vedges;
    dedges0                 = dedges;
    fedges0                 = fedges;
    cedges0                 = cedges;
    vedges                  = cell( 1, ntypes );
    dedges                  = cell( 1, ntypes );
    fedges                  = cell( 1, ntypes );
    cedges                  = cell( 1, ntypes );
    for k                   = 1 : ntypes
        vedges{ k }         = vedges0;
        dedges{ k }         = dedges0;
        fedges{ k }         = fedges0;
        cedges{ k }         = cedges0;
    end
    
elseif h == 1 
    
    gmm                     = repmat( gmm, [ 1 ntypes ] );
    
end

%------------------------------------------------------------------%
% actually categorize
%------------------------------------------------------------------%
changed                     = false( nstims, 1 );
for i                       = 1 : nstims

    c0                      = stims( i ).category;
    nevents                 = size( stims( i ).times, 1 );
    if ~nevents
        continue
    end
    stims( i ).category     = zeros( nevents, 3 );
    
    for k                   = 1 : ntypes
        typek               = utypes{ k };
        sidx                = ismember( upper( stims( i ).types ), typek );
        nidx                = sum( sidx );
        if nidx == 0
            continue
        end
        switch typek
            case 'SINES'
                vals        = stims( i ).vals( sidx );
                durs        = stims( i ).franges( sidx, 1 );
            case 'WN'
                vals        = stims( i ).stats( sidx, 1 );
                durs        = stims( i ).stats( sidx, 2 );
            case 'ZAP'
                vals        = stims( i ).vals( sidx );
                durs        = diff( stims( i ).franges( sidx, : ), [], 2 );
            otherwise
                vals        = stims( i ).vals( sidx );
                durs        = stims( i ).durs( sidx );
        end
        data                = [ vals durs ];
        if datadependentBinning
            % ignore covariances (i.e. by nearest neighbour, ensures monotonicity)
            [ ~, clu1 ]     = min( pdist2( data( :, 1 ), gmm{ 1, k }.mu, 'euclidean' ), [], 2 );
            [ ~, clu2 ]     = min( pdist2( data( :, 2 ), gmm{ 2, k }.mu, 'euclidean' ), [], 2 );
            clu             = [ clu1 clu2 ];
        else
            switch typek
                case 'SINES'
                    edges   = [ vedges( k ) fedges( k ) ];
                case 'WN'
                    edges   = [ vedges( k ) dedges( k ) ];
                case 'ZAP'
                    edges   = [ vedges( k ) cedges( k ) ];
                otherwise
                    edges   = [ vedges( k ) dedges( k ) ];
            end
            [ bdata, bins, clu ] = bindata( data, edges );
        end
        stims( i ).category( sidx, : ) = [ ones( nidx, 1 ) * k clu ]; 
    end
    
    if ~isequal( c0, stims( i ).category )
        changed( i )        = 1;
    end
    
end

%------------------------------------------------------------------%
% update the category field of a simultaneous strucutre
%------------------------------------------------------------------%
for i                       = 1 : nstims
    issim                   = length( stims( i ).chan ) > 1;
    if ~issim
        continue;
    end
    lg                      = stims( i ).index > 0; 
    urows                   = unique( lg, 'rows' ); 
    scat                    = zeros( size( lg, 1 ), 1 );
    for k                   = 1 : size( urows, 1 )
        ridx                = ismember( lg, urows( k, : ), 'rows' ); 
        scat( ridx, : )     = k;
    end
    stims( i ).category( :, 4 ) = scat;
end

%------------------------------------------------------------------%
% update the saved structures on disk
%------------------------------------------------------------------%
% determine where to save
if isempty( filebase ) && exist( fileparts( stims( 1 ).filebase ), 'dir' )
    filebase                = stims( 1 ).filebase;
end
if isempty( filebase ) && Overwrite ~= 0
    verb( sprintf( '%s: Cannot save at %s', mfname, stims( 1 ).filebase ), vflag )
    return
end

% actually save
for i                       = 1 : nstims
    stim                    = stims( i );
    if length( stim.chan ) > 1 || isa( stim.source, 'cell' )
        savename            = sprintf( '%s.stm.sim', filebase );
    else
        savename            = sprintf( '%s.stm.%s', filebase, num3str( stim.chan ) );
    end
    nex                     = ~exist( savename, 'file' );
    if Overwrite >= 0 || Overwrite ~= -1 && ( nex || changed( i ) )
        if ~nex
            L               = load( savename, 'stim', '-mat' );
        else
            L.stim          = stim;
        end
        if ~isequal( L.stim, stim )
            verb( sprintf( '%s: saving %s...', mfname, savename ), vflag )
            save( savename, 'stim', '-v6' )
        end
    end
end

return

% EOF

